#!/usr/bin/perl -w

# divvy is a command line utility for splitting text lines (like those from log files) into separate files based on pattern matching.  
#
# Laziness, Impatience, Hubris: Yes!
#
# Written and maintained by: 
#   Kenny Katzgrau 
#   katzgrau@gmail.com
#   http://codefury.net
# Project maintained at:
#   http://github.com/katzgrau/divvy

use strict;
no strict 'refs';

use Data::Dumper;

# If you make a new handler in the handler section, add it here
# Will hold keys to arrays of index ids to handers
my @handler_types = qw/log exec pexec screen mail/;

# Will hold options/switched
my @option_types = qw/follow/;

# Will hold the patterns that we're looking for
my %patterns = ();

# Will hold a filename to parse as a log file. If this isn't
#  specified, we'll use STDIN
my $logfile = '';

# Will hold the functions for dealing with lines matching patterns
my %handlers = ();

# Will hold the options that have been specified
my %options = ();

# Holds indexes to the handlers associated with them
my %index_to_handler = ();

# ------------------------------------------------------------
# Section: Core function definitions
#  If you want to add new handlers or things like that, add them 
#  in the section below this one.
# ------------------------------------------------------------

# Validate all of the command line arguments, parse them
#  and store them in global vars for later use
sub validate_args() {
  # Go through each argument
  foreach (@ARGV) {
    # Does it look like a valid argument?
    if(my ($handler, $index, $argument) = /\-\-([a-zA-Z\-]+)(\d+)?=?(?:["']?)([^'"]*)(?:["']?)/) {
      if($handler eq "match") {
        # It's a 'match' argument specifying a pattern
        $patterns{$index} = $argument; 
      } elsif (defined $handlers{$handler}) {
        # It's a handler specifying what to do with a match
        $handlers{$handler}{$index} = $argument;    
        if(!defined($index_to_handler{$index})) {
          $index_to_handler{$index} = [];
        }
        push(@{$index_to_handler{$index}}, $handler);
      } elsif (defined $options{$handler}){
        # It's an option. We'll mark that it was specified
        $options{$handler} = 1;
      } elsif ($handler eq 'help') {
        print_usage();
      } else {
        # If it's not a match, handler, or option, it must be a log file to open
        $logfile = $handler; 
      }
    } else {
      $logfile = $_; 
    }
  }  
}

# This is the main program loop. Roll through standard input
#  and try matching each line with any patterns that have
#  been specified as arguments. If we have matches, execute
#  the handlers for that match.
sub main {
  # Roll through each line of STDIN, and if it matches a pattern,
  # execute any corresponding handlers
  # Allocate a bunch of hashes to hold arguments
 
  # Initialize, the handler array!
  foreach(@handler_types) {
    $handlers{$_} = {};
  }

  # Initialize the option array!
  foreach(@option_types) {
    $options{$_} = 0;
  }

  # Second, validate the args!
  validate_args();

  # Get the input stream (STDIN or a file)
  my $input = get_input();

  # Execute any pre-processing hooks
  execute_all_hooks('open');

  # Now do the handywork
  #  We keep track of *where* exactly we are in the input stream
  #  in case the --follow flag is specified. This is so we can
  #  continually take in new input
  while(my $line = <$input>) {
    # Get the position
    my $pos = tell($input);
    chomp($line);
    foreach my $idx (keys %patterns) {
      $_ = $line;
      if(/$patterns{$idx}/) {
        execute_all_handlers($idx, $line);
      }
    }
    # Are we tailing a file? Then we need to clear the EOF
    #  and seek until the end
    if (get_opt('follow')) {
      seek($input, $pos, 1);
    }
  }
  # Execute any post-processing hooks
  execute_all_hooks('close');
}

# Get the input stream. it might be a file specified as an argument.
#  If no filename args are present, read from STDIN
sub get_input {
  my $input_handle = 0;
  if($logfile) {
    # A logfile was specified as input
    $input_handle = 'input_handle';
    if(get_opt('follow')) {
      # Pipe from tail! First, WTH is tail? /usr/bin? Don't be naive..
      my $tail = `which tail`;
      chomp($tail);
      open $input_handle, '-|', $tail, '-f', $logfile, '-n', '0';
    } else {
      # Uh oh, the log file doesn't exist :'(
      fatal("Input file specified does not exist: $logfile") if (! -e $logfile);
      open $input_handle, '<', $logfile;
    }
  } else {
    # Read from STDIN instead
    $input_handle = *STDIN;
  }
  # Return an input handle
  return $input_handle;
}

# Given the index of a matching pattern (specified by user
#  at the command line), and the line of matching input
#  execute all handlers that may have been specified.
sub execute_all_handlers {
  my ($matching_index, $line) = @_;
  foreach my $handler (@{$index_to_handler{$matching_index}}) {
    my $func = "handle_$handler";
    if(defined(&$func)) {
      &$func($matching_index, $line); 
    }
  }
}

# Execute a hook function for any handlers that have been
#  specified if they exist
sub execute_all_hooks {
  my ($type) = @_;
  foreach my $handler (@handler_types) {
    my $func = 'handle_'.$handler.'_'.$type;
    if(defined(&$func)) {
      &$func();
    }
  }
}

# Given the type of handler, and the index of the match,
#  get the argument/paramater that was specified by the 
#  user. Ex, a param looks like: --[type][index]=[arg]
sub get_arg {
  my ($type, $index) = @_;
  return $handlers{$type}{$index};
}

# Given the name of an option, check whether it was
#  specified or not
sub get_opt {
  my ($name) = @_;
  return $options{$name};
}

# Print out a message and exit the script. Basically used
#  for errors
sub fatal {
  my ($message) = @_;
  print $message . "\n";
  exit;
}

# Print a help message. This will print instructions and exit.
sub print_usage {
  print qq/
  Usage: divvy [options] [--matchN] [--handlerN] [filename]

  Example: divvy --follow --match0=ERROR --mail0='katzgrau\@gmail.com' logfile.txt

/;
  exit;
}
# ------------------------------------------------------------
# Section: Match Handlers
#  Any match specified by a user can (and should) have a
#  corresponding handler assigned to it. If an arg is passed
#  on the command line like --foo25=mammajamma, then it's
#  expected that there is a handle_foo function.
#  Access to the 'mammajamma' arg can be retrieved by get_arg()
# ------------------------------------------------------------

# Allow a user to specify an arbitrary unix command to execute
# if a line is find. Allow them to specify {{LINE}} if they
# want that line somehow inserted in that command
sub handle_exec {
  my ($index, $line) = @_;
  my $cmd = get_arg('exec', $index);
  $cmd =~ s/\{\{LINE\}\}/$line/g;
  print `$cmd`;  
}

# Allow a user to specify an arbitrary command to execute
#  for a line, but the line will be piped into the command.
#
sub handle_pexec {
  my ($index, $line) = @_;
  my $cmd = get_arg('pexec', $index);
  $cmd =~ s/\{\{LINE\}\}/$line/g;
  open pipe_out, '|', $cmd;
  print pipe_out $line . "\n";
  close(pipe_out);
}

# Any matches should be emailed to the address specified by the argument
my $buffer = ();
sub handle_mail {
  my ($index, $line) = @_;
  my $cmd = get_arg('pexec', $index);
  $cmd =~ s/\{\{LINE\}\}/$line/g;
  open(pipe_out, '| mail ', '-s', "divvy matched '. $patterns{$index} .'", '-t', get_arg('mail', $index));
  print pipe_out $line."\n";
  close(pipe_out);
}

# A handler for allowing the user to log a matching line to a
# file. The argument passed on the command line should be
# the filepath to log to.
# Define log_files here to keep this handler all in one place
my %log_files = (); 
sub handle_log {
  my ($index, $line) = @_;
  # Is there a file stream already open?
  #  If not, open it
  if(!defined($log_files{$index})) {
    $log_files{$index} = "file_handle_$index"; 
    my $filename = get_arg("log", $index);
    open($log_files{$index}, '>', $filename);
  }
  # Write to the log file
  print {$log_files{$index}} $line."\n";
}

# A handler for letting the user log matching lines to the
# screen. Useful to see important stuff go by, or to perhaps
# specify .* (any) as an argument and use this script like `tee` 
sub handle_screen {
  my ($index, $line) = @_;
  print $line."\n";
}

# ------------------------------------------------------------
# Kickoff the main program loop
main;

#print Dumper(@ARGV);
#print Dumper(\%patterns) . "\n" ;
#print Dumper(\%handlers) . "\n" ;
#print Dumper(\%index_to_handler) . "\n" ;
#print Dumper(\%options) . "\n" ;
